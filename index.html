<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Dojo — A〜Z候補 + 説明 + 必ず書ける</title>
  <style>
    body{font-family:-apple-system,system-ui,sans-serif;margin:12px}
    h2{margin:8px 0}
    .hint{opacity:.78;font-size:12px;line-height:1.35;margin:6px 0 10px}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}
    button{padding:10px 14px;border-radius:10px;border:1px solid #ccc;background:#fff}
    button:active{transform:scale(.98)}
    #out{background:#111;color:#0f0;padding:10px;border-radius:10px;min-height:110px;white-space:pre-wrap;overflow:auto}

    /* エディタ（大きい） */
    #editorWrap{margin:10px 0}
    #editorFallback{
      width:100%; height:520px;
      border:1px solid #ddd; border-radius:12px;
      padding:10px;
      font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size:14px; line-height:1.35;
      box-sizing:border-box;
    }
    #editor{
      width:100%; height:520px;
      border:1px solid #ddd;border-radius:12px;
      overflow:hidden;display:none;
    }

    /* 候補 */
    #suggest{
      display:none;
      border:1px solid #ddd;
      border-radius:12px;
      padding:6px;
      margin-top:8px;
      background:#fff;
      font-size:13px;
      max-height:220px;
      overflow:auto;
    }
    .sItem{
      padding:8px;
      border-radius:10px;
      cursor:pointer;
      border:1px solid rgba(0,0,0,0.06);
      margin:6px 0;
    }
    .sItem:active{transform:scale(.99)}
    .sKey{font-weight:900}
    .sDesc{opacity:.7;font-size:12px;margin-top:2px}

    /* 説明 */
    #doc{
      border:1px solid #ddd;
      border-radius:12px;
      padding:10px;
      margin-top:10px;
      background:#fff;
      font-size:13px;
      white-space:pre-wrap;
    }
    #docTitle{font-weight:900;margin-top:6px}
    #docBody{opacity:.85;margin-top:6px}

    /* ステージ */
    #stage{
      width:100%;max-width:360px;aspect-ratio:9/16;
      border:1px solid #bbb;border-radius:16px;
      background:#f7f7f7;position:relative;overflow:hidden
    }
    code{background:rgba(0,0,0,.06);padding:1px 6px;border-radius:8px}
  </style>
</head>
<body>
  <h2>Dojo（A〜Z候補 + 説明 + 必ず書ける）</h2>
  <div class="hint">
    ✅ 書く場所：下の「Lua Editor」（Monaco失敗でもtextareaで必ず書ける）<br>
    ✅ 予測変換：エディタで <b>a〜z を1文字打つ</b>（例：<code>l</code>）→ 候補が出る → タップで挿入＆説明更新<br>
    ✅ 実行：<b>Run</b> → Output。白い枠タップで <code>Input.onTap</code> が動く
  </div>

  <div class="row">
    <button id="run">Run</button>
    <button id="reset">Reset</button>
    <button id="clear">Clear Output</button>
  </div>

  <div id="out"></div>

  <div id="editorWrap">
    <div class="hint"><b>Lua Editor（ここに書く）</b></div>

    <!-- 必ず出るフォールバック -->
    <textarea id="editorFallback">
-- ここにLuaを書く（この箱は必ず出る）
-- ためしに「l」と打って候補を出してみて

print("Ready! Tap the stage")

Input.onTap(function(x, y)
  print("Tap:", x, y)
end)
</textarea>

    <!-- Monacoがロードできたらこっちを表示 -->
    <div id="editor"></div>

    <!-- 候補 -->
    <div id="suggest"></div>

    <!-- 説明パネル -->
    <div id="doc">
      <b>説明</b>
      <div id="docTitle">（候補をタップするとここにタイトル）</div>
      <div id="docBody">（ここに詳しい説明）</div>
    </div>
  </div>

  <div class="hint">↓ ここをタップするとイベント発火（座標がOutputに出る）</div>
  <div id="stage"></div>

<hr style="margin:18px 0;border:none;border-top:1px solid #ddd">

<div id="aiPanel" style="border:1px solid #ddd;border-radius:12px;background:#fff;padding:10px">
  <div style="display:flex;justify-content:space-between;align-items:center;gap:10px">
    <b>LocalScript専用AI（学習コーチ）</b>
    <span style="font-size:12px;padding:3px 8px;border:1px solid #ddd;border-radius:999px;opacity:.75">offline</span>
  </div>

  <div style="opacity:.75;font-size:12px;line-height:1.35;margin-top:6px">
    例：<code>カウンター</code> / <code>ON/OFF</code> / <code>タップ座標</code> / <code>Studioでの書き方</code>
  </div>

  <div id="aiLog" style="height:240px;overflow:auto;border:1px solid #ddd;border-radius:12px;padding:10px;margin-top:10px;white-space:pre-wrap"></div>

  <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:10px">
    <button class="aiChip" data-q="カウンターを作りたい">カウンター</button>
    <button class="aiChip" data-q="ON/OFF切り替えたい">ON/OFF</button>
    <button class="aiChip" data-q="タップした座標を表示したい">タップ座標</button>
    <button class="aiChip" data-q="Roblox Studioで動くLocalScript例がほしい">Studio例</button>
  </div>

  <textarea id="aiInput" style="width:100%;min-height:84px;border:1px solid #ddd;border-radius:12px;padding:10px;font-size:14px;box-sizing:border-box;margin-top:10px"
    placeholder="やりたいことを書いて送信（例：ボタンでON/OFF切り替えたい）"></textarea>

  <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:10px">
    <button id="aiSend">送信</button>
    <button id="aiInsert">おすすめをエディタに挿入</button>
    <button id="aiClear">AIログ消し</button>
  </div>
</div>

  <!-- Lua VM -->
  <script src="https://cdn.jsdelivr.net/npm/fengari-web/dist/fengari-web.js"></script>
  <!-- Monaco（読み込めたら使う。ダメでもtextareaがある） -->
  <script src="https://unpkg.com/monaco-editor@0.45.0/min/vs/loader.js"></script>

  <script>
    const out = document.getElementById("out");
    const stage = document.getElementById("stage");
    const runBtn = document.getElementById("run");
    const resetBtn = document.getElementById("reset");
    const clearBtn = document.getElementById("clear");

    const editorDiv = document.getElementById("editor");
    const editorFallback = document.getElementById("editorFallback");
    const suggestBox = document.getElementById("suggest");

    const docTitle = document.getElementById("docTitle");
    const docBody  = document.getElementById("docBody");

    let running = false;
    let tapHandlers = [];
    let editor = null; // Monaco instance (optional)

    function logLine(s){
      out.textContent += String(s) + "\n";
      out.scrollTop = out.scrollHeight;
    }

    // 改行事故を避ける：Lua側で \n を作らず、JS側で改行付ける
    window.appendOutput = (s)=> { logLine(s); };
    window.__inputOnTap = (fn)=> { tapHandlers.push(fn); };

    stage.onclick = (e)=>{
      if(!running) return;
      const r = stage.getBoundingClientRect();
      const x = Math.round(e.clientX - r.left);
      const y = Math.round(e.clientY - r.top);
      for (const fn of tapHandlers) {
        try { fn(x,y); } catch(err) { logLine("JS handler error: " + err); }
      }
    };

    function wrap(userCode){
      return `
Input = {}
function Input.onTap(fn) js.global:__inputOnTap(fn) end

print = function(...)
  local t = {}
  for i=1,select('#', ...) do
    t[#t+1] = tostring(select(i, ...))
  end
  js.global:appendOutput(table.concat(t, " "))
end

${userCode}
`;
    }

    function getEditorText(){
      if (editor && typeof editor.getValue === "function") return editor.getValue();
      return editorFallback.value || "";
    }
    function setEditorText(v){
  if (editor && typeof editor.setValue === "function") editor.setValue(v);
  else editorFallback.value = v;
}

// ★ここに入れる（この位置が正解）
window.Dojo = window.Dojo || {};
window.Dojo.setEditorText = setEditorText;
window.Dojo.showDoc = showDoc;
window.Dojo.getEditor = () => editor;
window.Dojo.editorFallback = editorFallback;

    runBtn.onclick = ()=>{
      out.textContent = "";
      tapHandlers = [];
      running = true;

      if (!window.fengari || !fengari.load) {
        logLine("Lua engineが読み込めてない（通信/ブロックが原因かも）");
        return;
      }
      try {
        const userLua = getEditorText();
        fengari.load(wrap(userLua))();
      } catch (e) {
        logLine("Lua Error: " + (e && e.message ? e.message : e));
      }
    };

    resetBtn.onclick = ()=>{
      running = false;
      tapHandlers = [];
      out.textContent = "";
    };
    clearBtn.onclick = ()=>{ out.textContent = ""; };

    // ========= A〜Z テンプレ（自動生成） =========
    const LETTERS = "abcdefghijklmnopqrstuvwxyz".split("");

    function makeTemplates(letter){
      const L = letter;
      return [
        {
          key: `${L}.starter`,
          desc: "最小テンプレ（print + onTap）",
          doc:
`何が学べる？
- printの使い方（ログ出力）
- Input.onTap のイベント（コールバック）

いじる場所
- printの文字
- onTapの中身（タップ時の処理）`,
          code:
`print("${L}: Ready!")

Input.onTap(function(x, y)
  print("${L}: Tap", x, y)
end)`
        },
        {
          key: `${L}.tap`,
          desc: "タップ座標だけ出す",
          doc:
`何が学べる？
- x,y（座標）を受け取る
- 入力イベントの基本

発展
- 右側だけ反応など条件分岐
- タップ回数を数える`,
          code:
`Input.onTap(function(x, y)
  print("${L}: Tap", x, y)
end)`
        },
        {
          key: `${L}.counter`,
          desc: "カウンター（変数の練習）",
          doc:
`何が学べる？
- 変数（count）で状態を持つ
- イベントのたびに状態が変わる

発展
- 10回でメッセージを変える
- 減らす処理も足す`,
          code:
`local count = 0
print("${L}: counter ready")

Input.onTap(function()
  count = count + 1
  print("${L}: count", count)
end)`
        },
        {
          key: `${L}.toggle`,
          desc: "ON/OFF切り替え（boolの練習）",
          doc:
`何が学べる？
- true/false（ブール値）
- on = not on の定番パターン

発展
- ONの時だけカウント
- OFFでリセット`,
          code:
`local on = false
print("${L}: toggle ready")

Input.onTap(function()
  on = not on
  print("${L}: state", on and "ON" or "OFF")
end)`
        }
      ];
    }

    const TEMPLATE_DB = Object.fromEntries(LETTERS.map(ch => [ch, makeTemplates(ch)]));
    // ===== LocalScript辞書（学習用DB）=====
const LS_DB = [
  {
    key: "service.get",
    tags: ["基本","Service","game"],
    desc: "Service取得（GetService）",
    doc: "Robloxの基本。Serviceはこれで取る。\n例：Players, UserInputService, RunService など。",
    code:
`local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")`
  },
  {
    key: "player.local",
    tags: ["Players","LocalPlayer"],
    desc: "LocalPlayer取得",
    doc: "LocalScriptで自分のプレイヤーを取る定番。",
    code:
`local Players = game:GetService("Players")
local player = Players.LocalPlayer`
  },
  {
    key: "ui.screenGui",
    tags: ["UI","PlayerGui","ScreenGui"],
    desc: "ScreenGui作成（PlayerGuiへ）",
    doc: "自分の画面UIの土台。ResetOnSpawn=falseでリスポーンでも残る。",
    code:
`local Players = game:GetService("Players")
local player = Players.LocalPlayer
local gui = Instance.new("ScreenGui")
gui.Name = "DojoGUI"
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")`
  },
  {
    key: "input.tap",
    tags: ["Input","UserInputService","Touch","Mouse"],
    desc: "タップ/クリック検知（UIS.InputBegan）",
    doc: "モバイル/PC両対応の入力検知。gameProcessedならUI操作中なので無視する。",
    code:
`local UIS = game:GetService("UserInputService")

UIS.InputBegan:Connect(function(input, gameProcessed)
  if gameProcessed then return end
  if input.UserInputType == Enum.UserInputType.Touch
    or input.UserInputType == Enum.UserInputType.MouseButton1 then
    print("Tapped/Clicked")
  end
end)`
  },
  {
    key: "loop.render",
    tags: ["RunService","RenderStepped"],
    desc: "毎フレーム処理（RenderStepped）",
    doc: "画面更新に合わせて動く。UI追従・カメラ補助などに使う（重い処理はNG）。",
    code:
`local RunService = game:GetService("RunService")

RunService.RenderStepped:Connect(function(dt)
  -- dt: 前フレームからの秒
end)`
  },
  {
    key: "state.toggle",
    tags: ["state","bool","pattern"],
    desc: "ON/OFFトグルの定番",
    doc: "LocalScriptの状態管理の超基本。on = not on",
    code:
`local on = false
local function set(v)
  on = v
  print("state:", on and "ON" or "OFF")
end

set(false)

-- 例：どこかのボタンで
set(not on)`
  },
];

    function showDoc(item){
      docTitle.textContent = item.key + " — " + item.desc;
      docBody.textContent  = item.doc || "（説明がまだない）";
    }

    function currentToken(text){
      const m = (text || "").match(/([A-Za-z][A-Za-z0-9\._]*)$/);
      return m ? m[1].toLowerCase() : "";
    }

    function hideSuggest(){
      suggestBox.style.display = "none";
      suggestBox.innerHTML = "";
    }

    function showSuggest(list){
      suggestBox.innerHTML = "";
      list.forEach(item => {
        const div = document.createElement("div");
        div.className = "sItem";
        div.innerHTML = `<div class="sKey">${item.key}</div><div class="sDesc">${item.desc}</div>`;
        div.onclick = () => {
          showDoc(item);
          setEditorText(item.code);
          hideSuggest();
        };
        suggestBox.appendChild(div);
      });
      suggestBox.style.display = "block";
    }

    function handleSuggest(){
  const text = getEditorText();
  const tok = currentToken(text);
  if (!tok) { hideSuggest(); return; }

  const q = tok.toLowerCase();

  // ===== 1) LS_DB検索（2文字以上で動く）=====
  // service / input / ui / player など
  if (q.length >= 2 && typeof LS_DB !== "undefined") {
    const listLS = LS_DB.filter(it => {
      const key  = String(it.key  || "").toLowerCase();
      const desc = String(it.desc || "").toLowerCase();
      const doc  = String(it.doc  || "").toLowerCase();
      const tags = (it.tags || []).map(t => String(t).toLowerCase());
      return key.includes(q) || desc.includes(q) || doc.includes(q) || tags.some(t => t.includes(q));
    }).slice(0, 12);

    if (listLS.length) { showSuggest(listLS); return; }
  }

  // ===== 2) A〜Zテンプレ検索（今まで通り）=====
  const first = q[0];
  if (!TEMPLATE_DB[first]) { hideSuggest(); return; }

  let list = TEMPLATE_DB[first];

  // 例：l.t みたいに入力が進んだら絞る
  if (q.length > 1) list = list.filter(x => x.key.startsWith(q));

  list = list.slice(0, 12);
  if (!list.length) { hideSuggest(); return; }

  showSuggest(list);
}

    // textarea監視
    editorFallback.addEventListener("input", handleSuggest);
    editorFallback.addEventListener("focus", handleSuggest);

    // 初期説明：l.starter
    showDoc(TEMPLATE_DB["l"][0]);

    // ========= Monaco init（成功したらtextareaを置き換え） =========
    (function initMonaco(){
      if (!window.require) {
        logLine("Monaco未使用（textareaでOK）。");
        return;
      }
      try {
        require.config({ paths: { vs: "https://unpkg.com/monaco-editor@0.45.0/min/vs" } });
        require(["vs/editor/editor.main"], function () {
          const initial = editorFallback.value || "";
          editor = monaco.editor.create(editorDiv, {
            value: initial,
            language: "lua",
            theme: "vs",
            automaticLayout: true,
            minimap: { enabled: false },
            fontSize: 14,
            wordWrap: "on",
            scrollBeyondLastLine: false
          });
          window.__dojoMonacoEditor = editor;
          window.__dojoMonacoModel = editor.getModel();

          editorFallback.style.display = "none";
          editorDiv.style.display = "block";

          editor.onDidChangeModelContent(handleSuggest);
          editor.onDidFocusEditorText(handleSuggest);

          logLine("Editor Ready（a〜z候補 + 説明）");
          handleSuggest();
        });
      } catch (e) {
        logLine("Monaco初期化に失敗（textareaで続行）: " + (e.message || e));
      }
    })();
    // =====================
// Part A: LocalScript専用AI（offline）
// =====================
const aiLog = document.getElementById("aiLog");
const aiInput = document.getElementById("aiInput");
const aiSend = document.getElementById("aiSend");
const aiInsert = document.getElementById("aiInsert");
const aiClear = document.getElementById("aiClear");

let aiBest = TEMPLATE_DB["l"][0];

function aiWrite(role, text){
  const block = document.createElement("div");
  block.style.margin = "10px 0";
  block.innerHTML = `<div style="font-weight:900;font-size:12px;opacity:.65">${role}</div>
                     <div style="margin-top:4px;font-size:13px;line-height:1.35;white-space:pre-wrap">${escapeHtml(text)}</div>`;
  aiLog.appendChild(block);
  aiLog.scrollTop = aiLog.scrollHeight;
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

function norm(s){ return (s||"").toLowerCase().trim(); }
function isUnsafe(s){
  // 不正利用（回避/チート/エグゼ系）は拒否
  const bad = [
 jsjs
  ];
  const x = norm(s);
  return bad.some(k => x.includes(k));
}

function score(prompt, item){
  const p = norm(prompt);
  let s = 0;
  if (p.includes("カウンター") || p.includes("counter") || p.includes("回数")) if (item.key.endsWith(".counter")) s += 7;
  if (p.includes("on/off") || p.includes("オンオフ") || p.includes("トグル") || p.includes("toggle") || p.includes("切り替え")) if (item.key.endsWith(".toggle")) s += 7;
  if (p.includes("タップ") || p.includes("tap") || p.includes("座標") || p.includes("クリック")) if (item.key.endsWith(".tap")) s += 7;
  if (p.includes("最初") || p.includes("基本") || p.includes("はじめ") || p.includes("スターター")) if (item.key.endsWith(".starter")) s += 5;

  const m = p.match(/\b([a-z])\b/);
  if (m && item.key.startsWith(m[1] + ".")) s += 2;

  return s;
}

function pickTemplates(prompt){
  const all = LETTERS.flatMap(ch => TEMPLATE_DB[ch]);
  const ranked = all.map(it => ({it, s: score(prompt, it)})).sort((a,b)=>b.s-a.s);
  const top = ranked[0].s > 0 ? ranked[0].it : TEMPLATE_DB["l"][0];
  aiBest = top;
  return ranked.filter(x=>x.s>0).slice(0,4).map(x=>x.it);
}

function studioExample(prompt){
  const p = norm(prompt);
  const wantsTap = p.includes("タップ") || p.includes("tap") || p.includes("クリック");
  const wantsToggle = p.includes("トグル") || p.includes("toggle") || p.includes("on/off") || p.includes("切り替え");
  const wantsCounter = p.includes("カウンター") || p.includes("counter") || p.includes("回数");

  let code =
`-- Roblox Studio用 LocalScript（自作ゲーム向け）
-- 置き場所：StarterPlayer > StarterPlayerScripts

local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")

local player = Players.LocalPlayer
local gui = Instance.new("ScreenGui")
gui.Name = "DojoGUI"
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")

local label = Instance.new("TextLabel")
label.Size = UDim2.new(0, 300, 0, 50)
label.Position = UDim2.new(0, 20, 0, 20)
label.Text = "Hello LocalScript"
label.Parent = gui
`;

  if (wantsToggle){
    code +=
`
local button = Instance.new("TextButton")
button.Size = UDim2.new(0, 300, 0, 50)
button.Position = UDim2.new(0, 20, 0, 80)
button.Text = "TOGGLE"
button.Parent = gui

local on = false
local function refresh()
  label.Text = "STATE: " .. (on and "ON" or "OFF")
end
refresh()

button.MouseButton1Click:Connect(function()
  on = not on
  refresh()
end)
`;
  }
  if (wantsCounter){
    code +=
`
local count = 0
local inc = Instance.new("TextButton")
inc.Size = UDim2.new(0, 300, 0, 50)
inc.Position = UDim2.new(0, 20, 0, 140)
inc.Text = "+1"
inc.Parent = gui

inc.MouseButton1Click:Connect(function()
  count += 1
  label.Text = "count = " .. count
end)
`;
  }
  if (wantsTap){
    code +=
`
UIS.InputBegan:Connect(function(input, gameProcessed)
  if gameProcessed then return end
  if input.UserInputType == Enum.UserInputType.MouseButton1
     or input.UserInputType == Enum.UserInputType.Touch then
    local pos = UIS:GetMouseLocation()
    label.Text = ("Tap: %d, %d"):format(pos.X, pos.Y)
  end
end)
`;
  }

  code +=
`
-- メモ：
-- LocalScriptは「入力」「GUI」「カメラ」など “自分だけの体験” が得意。
-- 共有したい処理はサーバー側（Script）＋RemoteEventでやる。
`;
  return code;
}

function aiHandle(text){
  if (isUnsafe(text)) {
    aiWrite("AI",
`それは不正利用（チート/回避/エグゼキュータ等）につながる可能性が高いから手伝えない。
代わりに「自作ゲーム向けの学習（UI/入力/状態管理/Studioでの正規API）」ならOK。

例：
- ボタンでON/OFF切り替えたい
- タップ座標を表示したい
- カウンターを作りたい`);
    aiBest = TEMPLATE_DB["l"][0];
    return;
  }

  const p = norm(text);
  if (p.includes("studio")) {
    aiWrite("AI", "【Roblox Studio用 LocalScript例】\n" + studioExample(text));
    return;
  }

  const picks = pickTemplates(text);
  const lines = picks.map((t,i)=>`${i+1}. ${t.key} — ${t.desc}`).join("\n");
  aiWrite("AI", `おすすめ候補：\n${lines}\n\nいちばん合いそう：${aiBest.key}\n（「おすすめをエディタに挿入」で入れられる）`);
  showDoc(aiBest);
}

aiSend.onclick = ()=>{
  const text = aiInput.value.trim();
  if(!text) return;
  aiWrite("You", text);
  aiInput.value = "";
  aiHandle(text);
};

aiInsert.onclick = ()=>{
  if (!aiBest || !aiBest.code) {
    aiWrite("AI", "先に送信しておすすめを出してね。");
    return;
  }

  // まず保険：textareaにも入れる（必ず存在する）
  const fb = document.getElementById("editorFallback");
  if (fb) fb.value = aiBest.code;

  const ed = window.__dojoMonacoEditor;
  const model = window.__dojoMonacoModel;

  // デバッグ表示（ここ重要）
  aiWrite("AI", "DEBUG: ed=" + (!!ed) + " model=" + (!!model) + " codeLen=" + aiBest.code.length);

  if (ed && model && typeof model.setValue === "function") {
    try {
      model.setValue(aiBest.code);    // ← 一番確実
　　　　// カーソルを「次の行の先頭」へ（例：9→10）
const p = ed.getPosition(); // いまの行
const nextLine = Math.min(p.lineNumber + 1, model.getLineCount());
ed.setPosition({ lineNumber: nextLine, column: 1 });
ed.revealLineInCenter(nextLine);
      ed.focus();

      // “本当に入ったか”を長さで確認
      const now = model.getValue().length;
      aiWrite("AI", "DEBUG: after setValue len=" + now);

      // 目視でも変化させる（カーソルを最後へ）
      const lineCount = model.getLineCount();
      const lastCol = model.getLineMaxColumn(lineCount);
      ed.setPosition({ lineNumber: lineCount, column: lastCol });
      ed.revealPositionInCenter({ lineNumber: lineCount, column: lastCol });

      aiWrite("AI", `Monacoに挿入した：${aiBest.key}`);
    } catch (e) {
      aiWrite("AI", "挿入エラー: " + (e.message || e));
    }
  } else {
    aiWrite("AI", "Monaco未準備。textareaに入れてる（下の白い方を確認して）");
    if (fb) fb.focus();
  }
};

aiClear.onclick = ()=>{
  aiLog.innerHTML = "";
  aiWrite("AI", "AIログを消した。やりたいことを送って。例：『カウンターを作りたい』");
};

document.querySelectorAll(".aiChip").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    aiInput.value = btn.getAttribute("data-q");
    aiSend.click();
  });
});

// 初期メッセージ
aiWrite("AI",
`使い方：
- 文章でやりたいことを書く → おすすめテンプレ提案
- "studio" を含めると Studio用LocalScript例を出す
- 「おすすめをエディタに挿入」でワンタップ挿入`);
  </script>
</body>
</html>