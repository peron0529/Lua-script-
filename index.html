<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Dojo — A〜Z予測変換 + 大きいエディタ</title>
  <style>
    body{font-family:-apple-system,system-ui,sans-serif;margin:12px}
    h2{margin:8px 0}
    .hint{opacity:.78;font-size:12px;line-height:1.35;margin:6px 0 10px}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}
    button{padding:10px 14px;border-radius:10px;border:1px solid #ccc;background:#fff}
    button:active{transform:scale(.98)}
    #out{background:#111;color:#0f0;padding:10px;border-radius:10px;min-height:110px;white-space:pre-wrap;overflow:auto}

    /* エディタ：大きく */
    #editorWrap{margin:10px 0}
    #editorFallback{
      width:100%; height:500px; /* ← 大きくした */
      border:1px solid #ddd; border-radius:12px;
      padding:10px;
      font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size:14px; line-height:1.35;
      box-sizing:border-box;
    }
    #editor{
      width:100%; height:500px; /* ← 大きくした */
      border:1px solid #ddd;border-radius:12px;
      overflow:hidden;display:none;
    }

    /* 予測変換ボックス */
    #suggest{
      display:none;
      border:1px solid #ddd;
      border-radius:12px;
      padding:6px;
      margin-top:8px;
      background:#fff;
      font-size:13px;
      max-height:220px;
      overflow:auto;
    }
    .sItem{
      padding:8px;
      border-radius:10px;
      cursor:pointer;
      border:1px solid rgba(0,0,0,0.06);
      margin:6px 0;
    }
    .sItem:active{transform:scale(.99)}
    .sKey{font-weight:900}
    .sDesc{opacity:.7;font-size:12px;margin-top:2px}

    #stage{
      width:100%;max-width:360px;aspect-ratio:9/16;
      border:1px solid #bbb;border-radius:16px;
      background:#f7f7f7;position:relative;overflow:hidden
    }
    code{background:rgba(0,0,0,.06);padding:1px 6px;border-radius:8px}
  </style>
</head>
<body>
  <h2>Dojo（a〜z予測変換 / 必ず書ける / 大きい）</h2>
  <div class="hint">
    ✅ 書く場所：下の「Lua Editor」<br>
    ✅ 予測変換：エディタで <b>a〜z を1文字打つ</b>（例：<code>l</code>）→ 候補が出る → タップで挿入<br>
    ✅ 実行：<b>Run</b> → Output。白い枠タップで <code>Input.onTap</code> が動く
  </div>

  <div class="row">
    <button id="run">Run</button>
    <button id="reset">Reset</button>
    <button id="clear">Clear Output</button>
  </div>

  <div id="out"></div>

  <div id="editorWrap">
    <div class="hint"><b>Lua Editor（ここに書く）</b></div>

    <!-- 必ず出るフォールバック（Monacoが死んでもここで書ける） -->
    <textarea id="editorFallback">
-- ここにLuaを書く（この箱は必ず出る）
-- ためしに l と打って候補を出してみて

print("Ready! Tap the stage")

Input.onTap(function(x, y)
  print("Tap:", x, y)
end)
</textarea>

    <!-- Monacoがロードできたらこっちを表示 -->
    <div id="editor"></div>

    <!-- 予測変換候補 -->
    <div id="suggest"></div>
  </div>

  <div class="hint">↓ ここをタップするとイベント発火（座標がOutputに出る）</div>
  <div id="stage"></div>

  <!-- Lua VM -->
  <script src="https://cdn.jsdelivr.net/npm/fengari-web/dist/fengari-web.js"></script>

  <!-- Monaco（読み込めたら使う。ダメでもtextareaがある） -->
  <script src="https://unpkg.com/monaco-editor@0.45.0/min/vs/loader.js"></script>

  <script>
    const out = document.getElementById("out");
    const stage = document.getElementById("stage");
    const runBtn = document.getElementById("run");
    const resetBtn = document.getElementById("reset");
    const clearBtn = document.getElementById("clear");

    const editorDiv = document.getElementById("editor");
    const editorFallback = document.getElementById("editorFallback");
    const suggestBox = document.getElementById("suggest");

    let running = false;
    let tapHandlers = [];
    let editor = null; // Monaco instance (optional)

    function logLine(s){
      out.textContent += String(s) + "\n";
      out.scrollTop = out.scrollHeight;
    }

    // 改行事故を避ける：Lua側で \n を作らず、JS側で改行付ける
    window.appendOutput = (s)=> { logLine(s); };
    window.__inputOnTap = (fn)=> { tapHandlers.push(fn); };

    stage.onclick = (e)=>{
      if(!running) return;
      const r = stage.getBoundingClientRect();
      const x = Math.round(e.clientX - r.left);
      const y = Math.round(e.clientY - r.top);
      for (const fn of tapHandlers) {
        try { fn(x,y); } catch(err) { logLine("JS handler error: " + err); }
      }
    };

    function wrap(userCode){
      return `
Input = {}
function Input.onTap(fn) js.global:__inputOnTap(fn) end

print = function(...)
  local t = {}
  for i=1,select('#', ...) do
    t[#t+1] = tostring(select(i, ...))
  end
  js.global:appendOutput(table.concat(t, " "))
end

${userCode}
`;
    }

    function getEditorText(){
      if (editor && typeof editor.getValue === "function") return editor.getValue();
      return editorFallback.value || "";
    }
    function setEditorText(v){
      if (editor && typeof editor.setValue === "function") editor.setValue(v);
      else editorFallback.value = v;
    }

    runBtn.onclick = ()=>{
      out.textContent = "";
      tapHandlers = [];
      running = true;

      if (!window.fengari || !fengari.load) {
        logLine("Lua engineが読み込めてない（通信/ブロックが原因かも）");
        return;
      }
      try {
        const userLua = getEditorText();
        fengari.load(wrap(userLua))();
      } catch (e) {
        logLine("Lua Error: " + (e && e.message ? e.message : e));
      }
    };

    resetBtn.onclick = ()=>{
      running = false;
      tapHandlers = [];
      out.textContent = "";
    };
    clearBtn.onclick = ()=>{ out.textContent = ""; };

    // ========= ② a〜z 予測変換（軽量・自動生成） =========
    const LETTERS = "abcdefghijklmnopqrstuvwxyz".split("");

    function makeTemplates(letter){
      const L = letter;
      return [
        {
          key: `${L}.starter`,
          desc: "最小テンプレ（print + onTap）",
          code:
`print("${L}: Ready!")

Input.onTap(function(x, y)
  print("${L}: Tap", x, y)
end)`
        },
        {
          key: `${L}.tap`,
          desc: "タップ座標だけ出す",
          code:
`Input.onTap(function(x, y)
  print("${L}: Tap", x, y)
end)`
        },
        {
          key: `${L}.counter`,
          desc: "カウンター（変数の練習）",
          code:
`local count = 0
print("${L}: counter ready")

Input.onTap(function()
  count = count + 1
  print("${L}: count", count)
end)`
        },
        {
          key: `${L}.toggle`,
          desc: "ON/OFF切り替え（boolの練習）",
          code:
`local on = false
print("${L}: toggle ready")

Input.onTap(function()
  on = not on
  print("${L}: state", on and "ON" or "OFF")
end)`
        }
      ];
    }

    const TEMPLATE_DB = Object.fromEntries(LETTERS.map(ch => [ch, makeTemplates(ch)]));

    function currentToken(text){
      // 最後の“単語”っぽい部分を取る（a / l. / l.t など）
      const m = (text || "").match(/([A-Za-z][A-Za-z0-9\._]*)$/);
      return m ? m[1].toLowerCase() : "";
    }

    function hideSuggest(){
      suggestBox.style.display = "none";
      suggestBox.innerHTML = "";
    }

    function showSuggest(list, typed){
      suggestBox.innerHTML = "";
      list.forEach(item => {
        const div = document.createElement("div");
        div.className = "sItem";
        div.innerHTML = `<div class="sKey">${item.key}</div><div class="sDesc">${item.desc}</div>`;
        div.onclick = () => {
          setEditorText(item.code);
          hideSuggest();
        };
        suggestBox.appendChild(div);
      });
      suggestBox.style.display = "block";
    }

    function handleSuggest(){
      const text = getEditorText();
      const tok = currentToken(text);

      if (!tok) return hideSuggest();

      const first = tok[0];
      if (!TEMPLATE_DB[first]) return hideSuggest();

      // 1文字だけ（例：l）で全部出す
      // それ以外（例：l.t）なら prefix一致で絞る
      const all = TEMPLATE_DB[first];
      let list = all;

      if (tok.length > 1) {
        list = all.filter(x => x.key.startsWith(tok));
      }

      // 入力が「l」でも、候補が多すぎて邪魔ならここで上限を切れる
      list = list.slice(0, 12);

      if (!list.length) return hideSuggest();
      showSuggest(list, tok);
    }

    // textareaは常時監視
    editorFallback.addEventListener("input", handleSuggest);
    editorFallback.addEventListener("focus", handleSuggest);

    // ========= Monaco init（成功したらtextareaを置き換え） =========
    (function initMonaco(){
      if (!window.require) {
        logLine("Monaco未使用（textareaでOK）。");
        return;
      }
      try {
        require.config({ paths: { vs: "https://unpkg.com/monaco-editor@0.45.0/min/vs" } });
        require(["vs/editor/editor.main"], function () {
          const initial = editorFallback.value || "";
          editor = monaco.editor.create(editorDiv, {
            value: initial,
            language: "lua",
            theme: "vs",
            automaticLayout: true,
            minimap: { enabled: false },
            fontSize: 14,
            wordWrap: "on",
            scrollBeyondLastLine: false
          });

          // textareaは隠してMonacoを表示
          editorFallback.style.display = "none";
          editorDiv.style.display = "block";

          // Monacoの変更を監視して予測変換
          editor.onDidChangeModelContent(handleSuggest);
          // クリック/フォーカスでも出す
          editor.onDidFocusEditorText(handleSuggest);

          logLine("Monaco Editor Ready（a〜z予測変換つき）");
          // 初回表示
          handleSuggest();
        });
      } catch (e) {
        logLine("Monaco初期化に失敗（textareaで続行）: " + (e.message || e));
      }
    })();
  </script>
</body>
</html>